\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{brumaltex3}[2024/01/07]

% \RequirePackage{expl3}[2023/12/08] % Not yet available on tectonic.
\ProvidesExplPackage{brumaltex3}{2024-01-07}{}{}

\RequirePackage{functional}[2023-01-07] % Not yet available on tectonic.
\Functional{scoping=true}

\RequirePackage{xparse}[2023-10-10]

\RequirePackage{amsmath}
\RequirePackage{amssymb}
\RequirePackage{amsthm}
\RequirePackage{mathtools}
\RequirePackage{physics}
\RequirePackage{csquotes}
\RequirePackage{mathrsfs}
\RequirePackage{stmaryrd}
\RequirePackage{dsfont}
\RequirePackage{bm}

\cs_new:Npn \brtWithTracing #1
    {\Functional{tracing=true}
     #1
     \Functional{tracing=false}}

% Create a new function after manipulating the first argument (name).
\prgNewFunction \prgNewFunction:Mnn {Mnn}
    {\prgNewFunction #1 {#2} {#3}}

% Evaluate the argument, discarding the result, adding nothing to input stream.
\prgNewFunction \brtVoid {m}
    {}

% Delete a function which has been previously defined by \prgNewFunction.
\prgNewFunction \__brt_fun_del:M {M}
    {\cs_undefine:N #1
     \cs_undefine:c {__fun_defined_ \cs_to_str:N #1 :w}}

% (Why we need a second version I don't understand.)
\prgNewFunction \__brt_fun_del:N {N}
    {\cs_undefine:N #1
     \cs_undefine:c {__fun_defined_ \cs_to_str:N #1 :w}}

\prgNewFunction \brtCallAnon {mn}
    {\__brt_fun_del:N \__brt_anon:m
     \prgNewFunction \__brt_anon:m {m} {\prgReturn {#2}}
     \prgReturn {\__brt_anon:m {#1}}}

% #1 = object being indexed
\msg_new:nnn {brumaltex3} {brtIndexError} {Index~out~of~bounds:~#1~[#2]}
\prgNewFunction \__brt_index_error:nm {nm}
    {\msg_error:nnnn {brumaltex3} {brtIndexError} {#1} {#2}}

\cs_new:Npn \NewCommandCopy:cc {\exp_args:Ncc \NewCommandCopy}
\cs_new:Npn \NewCommandCopy:cn {\exp_args:Nc \NewCommandCopy}

% Copy the second environment into the first.
\prgNewFunction \brt_env_set_eq:mm {mm}
    {\prgReturn
        {\NewCommandCopy:cc {#1} {#2}
         \NewCommandCopy:cc {end#1} {end#2}}}

\prgNewFunction \brt_cs_gset_eq:NN {NN}
    {\cs_gset_eq:cN {\cs_to_str:N #1 Old} #1
     \cs_gset_eq:NN #1 #2}
\cs_new:Npn \brt_cs_gset_eq:Nc {\exp_args:NNc \brt_cs_gset_eq:NN}

% Swap the commands, saving `...Old` versions.
\prgNewFunction \brt_cs_gswap:NN {NN}
    {\brt_cs_gset_eq:NN #1 #2
     \brt_cs_gset_eq:Nc #2 {\cs_to_str:N #1 Old}}

\prgNewFunction \brt_if:eTF {enn}
    {\bool_if:nTF {#1} {\prgReturn {#2}} {\prgReturn {#3}}}

% the quantity of objects on the "heap" (lol)
\intNew \g__brt_heap_size

% {} -> a new unique csname
\prgNewFunction \__brt_heap_alloc: {}
    {\tlSet \lTmpaTl {\expName {c__brt_heap_ \int_use:N \g__brt_heap_size}}
     \intIncr \g__brt_heap_size
     \prgReturn {\tlUse \lTmpaTl}}

% #1 = constant constructor; #2 = value; -> new constant
\prgNewFunction \__brt_make:Nm {Nm}
    {\tlSet \lTmpaTl {\__brt_heap_alloc:}
     #1 {\tlUse \lTmpaTl} {#2}
     \prgReturn {\tlUse \lTmpaTl}}

% \brt_seq_item:MmTF #1=seq {#2=index based at 1} {#3=true code} {#4=false code}
% True code takes one argument, the retrieved item.
% False code takes no arguments.
\prgNewFunction \brt_seq_item:MmTF {Mmnn}
    {\prgReturn
        {\brt_if:eTF
            {\intCompare {#2} > {\seqVarCount #1}
             || \intCompare {#2} < {1}}
            {#4}
            {\brtCallAnon {\seqVarItem #1 {#2}} {#3}}}}

% Rerieve an item from the sequence.
% If the index is out of bounds, then issue an error.
\prgNewFunction \brt_seq_item:Mm {Mm}
    {\prgReturn
        {\brt_seq_item:MmTF #1 {#2}
            {##1}
            {\prgDo {\__brt_index_error:nm {#1} {#2}}}}}

\DeclareOption {obj} {
    % the quantity of objects with id
    \intNew \g__brt_universe_size

    % \__brt_id_alloc: -> new unique id string
    \strClearNew \l__id
    \prgNewFunction \__brt_id_alloc: {}
        {\strSet \l__id {\evalWhole {brt Id \intUse \g__brt_universe_size}}
         \intIncr \g__brt_universe_size
         \prgReturn {\strUse \l__id}}

    % \brtObjCons {#2=args:keyvals} -> new object
    % If args does not provide @type=, then the object's @type is set to \brtTypeT.
    % The object is automatically given an @id=, which overrides any args.@id.
    % The @id= also serves as a name.
    % If @name= is provided, then it is assigned as a name.
    % The object's formatter is set to the type's default formatter.
    \propClearNew \l__args
    \strClearNew \l__id
    \tlClearNew \l__obj_p
    \prgNewFunction \brtObjCons {m}
        {\propSetFromKeyval \l__args {\evalWhole {#1}}
         \strSet \l__id {\__brt_id_alloc:}
         \propPutIfNew \l__args {@type} {\brtTypeT}
         \propPut \l__args {@id} {\strUse \l__id}
         \tlSet \l__obj_p {\__brt_make:Nm \propConstFromKeyval {\propToKeyval \l__args}}
         \brtObjName {\strUse \l__id} {\tlUse \l__obj_p}
         \propGetT \l__args {@name} \lTmpaTl
             {\brtObjName {\tlUse \lTmpaTl} {\tlUse \l__obj_p}}
         \brtObjFmtLike {\tlUse \l__obj_p} {\brtObjElim {@type} {\tlUse \l__obj_p}}
         \prgReturn {\tlUse \l__obj_p}}

    % \brtObjElim {#1=attribute/path/separated/by/slash} #2=obj:obj -> value
    \tlClearNew \l__obj_p
    \seqClearNew \l__keys
    \prgNewFunction \brtObjElim {mM}
        {\seqSetSplit \l__keys {/} {#1}
         \tlSet \l__obj_p {#2}
         \Functional{scoping=false} % TODO Sus.
         \seqVarMapInline \l__keys
            {\tlSet \l__obj_p {\propVarItem {\tlUse \l__obj_p} {##1}}}
         \Functional{scoping=true}
         \prgReturn {\tlUse \l__obj_p}}

    % \brtObjName {#1=name:str} #2=obj:obj -> void
    % A priori, names can be arbitrary token lists.
    % However, it is recommended that names be valid csnames (without using
    % \csname...\endcsname etc.) so that wrappers can construct convenient macros
    % around object names.
    \prgNewFunction \brtObjName {mM}
        {\tlConst {\expName {c__brt_obj_named_ #1}} #2}

    % \brtObjNamed {#1=name:str} -> object named "name"
    % Maps names to objects, not necessarily injectively.
    % An object's @id= also serves as a name.
    \prgNewFunction \brtObjNamed {m}
        {\prgReturn {\tlUse {\expName {c__brt_obj_named_ #1}}}}

    % \brtObjFmtSet #1=obj:obj {#2=fmtr:fun} -> void
    % Set the formatter for the object.
    \prgNewFunction \__brt_obj_fmt_p: {M}
        {\prgReturn {\expName {\evalWhole {__brt_obj_fmt_ \brtObjElim {@id} #1}}}}
    \prgNewFunction \brtObjFmtSet {Mn}
        {\__brt_fun_del:M {\__brt_obj_fmt_p: #1}
         \prgNewFunction:Mnn {\__brt_obj_fmt_p: #1} {M} {\prgReturn {#2}}}

    % \brtTypeFmtSet #1=obj:Type -> void
    % Set the formatter for the type, i.e. the default formatter for all inhabitants
    % of this type.
    \prgNewFunction \__brt_type_fmt_p {M}
        {\prgReturn {\expName {\evalWhole {__brt_type_fmt_ \brtObjElim {@id} #1}}}}
    \prgNewFunction \brtTypeFmtSet {Mn}
        {\__brt_fun_del:M {\__brt_type_fmt_p #1}
         \prgNewFunction:Mnn {\__brt_type_fmt_p #1} {M} {\prgReturn {#2}}}

    % \brtObjFmt #1=obj:obj -> formatted object
    \prgNewFunction \brtObjFmt {M}
        {\prgReturn {\evalWhole {\__brt_obj_fmt_p: #1 #1}}}

    % \brtObjFmtLike #1=obj:obj #2=type:Type -> void
    % Set the formatter for obj to the default formatter of type.
    % This is by ref, i.e. if type's default formatter changes, then so does obj.
    \prgNewFunction \brtObjFmtLike {MM}
        {\brtObjFmtSet #1 {\evalWhole {\__brt_type_fmt_p #2 ##1}}}

    % \brtTypeFmtGet #1=type:Type -> formatter for type
    \prgNewFunction \brtTypeFmtGet {M}
        {\prgReturn {\__brt_type_fmt_p #1}}

    % \brtObjShow #1=obj:obj -> string serialisation of object
    \prgNewFunction \brtObjShow {M}
        {\prgReturn {\tlToStr {\propToKeyval #1}}}

    % primitive type type (default formatter)
    % We have to create it by-hand to bootstrap the universe.
    \propConstFromKeyval \brtTypeT {@id = Type, @name = Type}
    \brtObjName {Type} {\brtTypeT}
    \brtObjFmtSet {\brtTypeT} {\brtObjShow #1}
    \brtTypeFmtSet {\brtTypeT} {\brtObjShow #1}

    % \brtObjPrimElim #1=obj:primitive -> primitive value
    \prgNewFunction \brtObjPrimElim {M}
        {\prgReturn {\brtObjElim {@value} #1}}

    % primitive integer type (eliminates to expl3 integer, formats to arabic)
    \brtTypeFmtSet
        {\brtObjCons {@type = \brtTypeT, @name = Int}}
        {\int_to_arabic:n {\brtObjPrimElim #1}}
    \prgNewFunction \brtIntCons {m}
        {\prgReturn
            {\brtObjCons
                {@type = \brtObjNamed {Int},
                 @value = {\__brt_make:Nm \intConst {#1}}}}}

    % primitive string type (eliminates and formats to expl3 string)
    \brtTypeFmtSet
        {\brtObjCons {@type = \brtTypeT, @name = Str}}
        {\brtObjPrimElim #1}
    \prgNewFunction \brtStrCons {m}
        {\prgReturn
            {\brtObjCons
                {@type = \brtObjNamed {Str},
                 @value = {\__brt_make:Nm \strConst {#1}}}}}

    % \brtSetupObj #1=\csname #2=obj -> void
    % Create two macros, \csname and \csnameO (the O stands for "abstract Object").
    % \csname returns the object formatted, i.e. \brtObjFmt {#2}.
    % \csnameO returns the abstract object, i.e. just #2.
    \prgNewFunction \brtSetupObj {MM}
        {\brtObjName {\cs_to_str:N #1} #2
         \prgNewFunction #1 {} {\prgReturn {\brtObjFmt {#2}}}
         \cs_gset_eq:cN {\cs_to_str:N #1 O} #2}

    % \brtSetupType #1=csname #2=type #3=cons:fun #4=fmt:fun -> void
    % Create two constructors (`cons`) for `type`, called \csname and \csnameO,
    % and sets the formatter for the type to `fmt`.
    % The constructor \csname returns a formatted object.
    % The consturctor \csnameO returns an abstract object.
    % Also create a macros \csnameT,\csnameTO which yields the type itself.
    % The constructor `cons` anonymous function receives a single argument
    % (probably a key-val list) and must return a key-val list that will be
    % passed to \brtObjCons.
    % The `cons` does not need to add @type=; that is appended automatically.
    % (TODO: I don't know why but replacing #3 below with something like \prgDo {#3}
    % causes an incromprehensible error.)
    \prgNewFunction \brtSetupType {MMnn}
        {\brtObjName {\cs_to_str:N #1} #2
         \prgNewFunction:Mnn {\expName {\cs_to_str:N #1 T}} {}
            {\prgReturn {\brtObjFmt {#2}}}
         \cs_gset_eq:cN {\cs_to_str:N #1 TO} #2
         \prgNewFunction #1 {m}
            {\prgReturn
                {\brtObjFmt
                    {\brtObjCons {#3, @type = #2}}}}
         \prgNewFunction:Mnn {\expName {\cs_to_str:N #1 O}} {m}
            {\prgReturn
                {\brtObjCons {#3, @type = #2}}}
         \brtTypeFmtSet #2 {#4}}
}

\DeclareOption {breaklessmaths} {
    % never ever break in maths mode
    \binoppenalty=\maxdimen
    \relpenalty=\maxdimen
    \sloppy
}

\DeclareOption {ref} {
    \RequirePackage{hyperref}
    \RequirePackage[nameinlink]{cleverref}
}

\DeclareOption {biblatex} {
    \RequirePackage[backend=bibtex,style=alphabetic,url=false,maxbibnames=4]{biblatex}
    % The user should use \addbibresource after loading this package.
}

\DeclareOption {environments} {
    \theoremstyle{plain}
    \newtheorem{theorem}{Theorem}[section]
    \newtheorem{proposition}[theorem]{Proposition}
    \newtheorem{lemma}[theorem]{Lemma}
    \newtheorem{fact}[theorem]{Fact}
    \newtheorem{claim}[theorem]{Claim}
    \newtheorem{corollary}[theorem]{Corollary}

    \theoremstyle{definition}
    \newtheorem*{definition}{Definition}
    \newtheorem{remark}[theorem]{Remark}
    \newtheorem*{remark*}{Remark}
    \newtheorem{question}{Question}
    \newtheorem{conjecture}{Conjecture}

    \AtEndOfPackage {
        \theoremstyle {plain}
    }
}

\DeclareOption {nestedproofs} {
    \brt_env_set_eq:mm {proofOld} {proof}
    \intZeroNew \g__brt_proof_nesting_level
    \seqClearNew \g__brt_proof_qed_symbols

    % \brtQedSet {#1=comma-delimited list of qed symbols} -> void
    % Set the QED symbols for nested proofs.
    % The left-most symbol is used for the top-level proof whilst the right-most
    % symbol is used for the deepest level proofs.
    \prgNewFunction \brtQedSet {m}
        {\seqSetFromClist \g__brt_proof_qed_symbols {#1}}

    \prgNewFunction \__brt_renew_qed:m {m}
        {\prgReturn {\renewcommand \qedsymbol {#1}}}

    \RenewDocumentEnvironment {proof} {O{Proof}}
        {\intIncr \g__brt_proof_nesting_level % top-most qed will be index 1
         \begin{proofOld}[#1]
         \__brt_renew_qed:m
             {\brt_seq_item:Mm \g__brt_proof_qed_symbols
                 {\intUse \g__brt_proof_nesting_level}}}
        {\end{proofOld}
         \intDecr \g__brt_proof_nesting_level}

    % Default qed symbols.
    \brtQedSet
        {\(\square\),
         \(\boxtimes\),
         \(\blacksquare\),
         \(\checkmark\),
         \texttt{\small QED},
         \textsf{\tiny QED}}
}

\DeclareOption {longhand} {
    % Useful macros for document authors that have long names prefixed by
    % `\brtLH...` which can be bound to the author's custom shorthands.
    % Although I try to tailor this module to a general audience, it undoubtably
    % makes opinionated choices about mathematical notation.

    % Text mode

    % TODO Build an index of terms defined by \brtLHDefine.
    \providecommand \brtLHDefine {\textbf}
    \providecommand \brtLHPredefine {\emph}

    % Maths mode

    % Needed inside of ExplSyntax.
    \providecommand \brtLHMaSubscript [2] {#1 \c_math_subscript_token {#2}}

    \providecommand \brtLHOperatorFmt [1] {\textsf {\upshape #1}}

    % \brtLHOperatorCons {csname} {symbol}
    \ProvideDocumentCommand \brtLHOperatorCons {mm}
        {\DeclareDocumentCommand {#1} {d()}
            {\brtLHOperatorFmt {#2}
             \IfValueT {##1} {\qty(##1)}}}

    \providecommand \brtLHProjectSymbol {\brtLHOperatorFmt {proj}}
    \providecommand \brtLHRestrictSymbol {\brtLHOperatorFmt {res}}

    \brtLHOperatorCons \brtLHDomainOp {dom}
    \brtLHOperatorCons \brtLHCodomainOp {codom}
    \brtLHOperatorCons \brtLHKernelOp {ker}
    \brtLHOperatorCons \brtLHCokernelOp {coker}
    \brtLHOperatorCons \brtLHImageOp {image}
    \brtLHOperatorCons \brtLHLimitOp {lim}
    \brtLHOperatorCons \brtLHDegreeOp {deg}
    \brtLHOperatorCons \brtLHSignOp {sgn}
    \brtLHOperatorCons \brtLHLengthOp {length}

    \providecommand \brtLHImageSet [2] {#1 \qty[#2]}
    \providecommand \brtLHInverseMap [1] {{#1}^{-1}}
    \providecommand \brtLHInverseSet [2] {\brtLHInverseMap {#1} \qty[#2]}

    \providecommand \brtLHCartesianPower [2] {{}^{#2}{#1}}

    \providecommand \brtLHRestrict [2] {#1 \restriction #2}

    \providecommand \brtLHMidQty [2] {\left.#1\ \middle\vert\ #2\right.}
    \providecommand \brtLHDivQty [2] {\left.#1\middle/#2\right.}
    \providecommand \brtLHSetCons [2] {\qty{\brtLHMidQty {#2} {#1}}}
    \providecommand \brtLHFamilyCons [2] {\brtLHMaSubscript {\qty(#2)} {#1}}

    % \brtLHIndexedFamily {index} {input expression} {output expression}
    \ProvideDocumentCommand \brtLHIndexedFamily {mmm}
        {\brtLHFamilyCons
            {\brtCallAnon {#1} {#2}}
            {\brtCallAnon {#1} {#3}}}

    % \brtLHIndexedSet {index} {input expression} {output expression}
    \ProvideDocumentCommand \brtLHIndexedSet {mmm}
        {\brtLHSetCons
            {\brtCallAnon {#1} {#2}}
            {\brtCallAnon {#1} {#3}}}

    \providecommand \brtLHFrom {\leftarrow}
    \providecommand \brtLHLogicalImplies {\Rightarrow}
    \providecommand \brtLHLogicalIff {\Leftrightarrow}

    \providecommand \brtLHDummyCdot {\,\cdot\,}
    \providecommand \brtLHAnonParamSymbol {\bullet}

    \providecommand \brtLHSeqConcatSymbol {{}^\frown}

    \providecommand \brtLHUnionSymbol {\bigcup}
    \providecommand \brtLHIntersectSymbol {\bigcap}
    \providecommand \brtLHCoproductSymbol {\bigsqcup}
    \providecommand \brtLHProductSymbol {\bigsqcap}
}

\DeclareOption {shorthand} {
    % The package author's shorthands. Beware.

    % TODO Setup a more robust depedency system (again).
    \ExecuteOptions{longhand}

    % Text mode

    \providecommand \define {\brtLHDefine}
    \providecommand \predefine {\brtLHPredefine}

    % Maths mode

    % when you only want one number for a multi-line equation block
    \providecommand \nn {\nonumber}

    \brt_cs_gswap:NN \epsilon \varepsilon
    \brt_cs_gswap:NN \phi \varphi
    \brt_cs_gset_eq:NN \leq \leqslant
    \brt_cs_gset_eq:NN \geq \geqslant

    \providecommand \project {\brtLHProjectSymbol}
    \providecommand \proj {\brtLHProjectSymbol}
    \providecommand \restrict {\brtLHRestrictSymbol}
    \providecommand \res {\brtLHRestrictSymbol}

    \providecommand \domain {\brtLHDomainOp}
    \providecommand \dom {\brtLHDomainOp}
    \providecommand \codomin {\brtLHCodomainOp}
    \providecommand \codom {\brtLHCodomainOp}
    \providecommand \ker {\brtLHKernelOp}
    \providecommand \coker {\brtLHCokernelOp}
    \providecommand \image {\brtLHImageOp}
    \providecommand \limit {\brtLHLimitOp}
    \providecommand \lim {\brtLHLimitOp}
    \providecommand \deg {\brtLHDegreeOp}
    \providecommand \sgn {\brtLHSignOp}
    \providecommand \length {\brtLHLengthOp}
    \providecommand \len {\brtLHLengthOp}

    \providecommand \imageset {\brtLHImageSet}
    \providecommand \inversemap {\brtLHInverseMap}
    \providecommand \inverseset {\brtLHInverseSet}

    \providecommand \cartpow {\brtLHCartesianPower}

    \providecommand \buildset {\brtLHSetCons}
    \providecommand \buildfamily  {\brtLHFamilyCons}

    \providecommand \idxedset {\brtLHIndexedSet}
    \providecommand \idxedfamily  {\brtLHIndexedFamily}

    \providecommand \from {\brtLHFrom}
    \providecommand \limplies {\brtLHLogicalImplies}
    \providecommand \liff {\brtLHLogicalIff}

    \providecommand \dummycdot {\brtLHDummyCdot}

    \providecommand \concat {\brtLHSeqConcatSymbol}

    \providecommand \union {\brtLHUnionSymbol}
    \providecommand \intersect {\brtLHIntersectSymbol}
    \providecommand \coproduct {\brtLHCoproductSymbol}
    \providecommand \product {\brtLHProductSymbol}
    \providecommand \coprod {\brtLHCoproductSymbol}
    \providecommand \prod {\brtLHProductSymbol}
}

\ProcessOptions\relax
