\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{brumaltex3}[2024/01/07]

% \RequirePackage{expl3}[2023/12/08] % Not yet available on tectonic.
\ProvidesExplPackage{brumaltex3}{2024-01-07}{}{}

\RequirePackage{functional}[2023-01-07] % Not yet available on tectonic.
\Functional{scoping=true}

\RequirePackage{xparse}[2023-10-10]

\RequirePackage{amsmath}
\RequirePackage{amssymb}
\RequirePackage{amsthm}
\RequirePackage{mathtools}
\RequirePackage{physics}
\RequirePackage{csquotes}
\RequirePackage{mathrsfs}
\RequirePackage{stmaryrd}
\RequirePackage{dsfont}
\RequirePackage{bm}

% Create a new function after manipulating the first argument (name).
\prgNewFunction \prgNewFunction:Mnn {Mnn}
    {\prgNewFunction #1 {#2} {#3}}

% Evaluate the argument, discarding the result, adding nothing to input stream.
\prgNewFunction \brtVoid {m}
    {}

% Delete a function which has been previously defined by \prgNewFunction.
\prgNewFunction \__brt_fun_del:M {M}
    {\cs_undefine:N #1
     \cs_undefine:c {__fun_defined_ \cs_to_str:N #1 :w}}

% (Why we need a second version I don't understand.)
\prgNewFunction \__brt_fun_del:N {N}
    {\cs_undefine:N #1
     \cs_undefine:c {__fun_defined_ \cs_to_str:N #1 :w}}

\prgNewFunction \brtCallAnon {mn}
    {\__brt_fun_del:N \__brt_anon:m
     \prgNewFunction \__brt_anon:m {m} {#2}
     \prgReturn {\__brt_anon:m {#1}}}

% #1 = object being indexed
\msg_new:nnn {brumaltex3} {brtIndexError} {Index~out~of~bounds:~#1~[#2]}
\prgNewFunction \__brt_index_error:nm {nm}
    {\msg_error:nnnn {brumaltex3} {brtIndexError} {#1} {#2}}

\cs_new:Npn \NewCommandCopy:cc {\exp_args:Ncc \NewCommandCopy}

% Copy the second environment into the first.
\prgNewFunction \brt_env_set_eq:mm {mm}
    {\prgReturn
        {\NewCommandCopy:cc {#1} {#2}
         \NewCommandCopy:cc {end#1} {end#2}}}

\prgNewFunction \brt_if:eTF {enn}
    {\bool_if:nTF {#1} {#2} {#3}}

% the quantity of objects on the "heap" (lol)
\intNew \g__brt_heap_size

% {} -> a new unique csname
\prgNewFunction \__brt_heap_alloc: {}
    {\tlSet \lTmpaTl {\expName {c__brt_heap_ \int_use:N \g__brt_heap_size}}
     \intIncr \g__brt_heap_size
     \prgReturn {\tlUse \lTmpaTl}}

% #1 = constant constructor; #2 = value; -> new constant
\prgNewFunction \__brt_make:Nm {Nm}
    {\tlSet \lTmpaTl {\__brt_heap_alloc:}
     #1 {\tlUse \lTmpaTl} {#2}
     \prgReturn {\tlUse \lTmpaTl}}

% \brt_seq_item:MmTF #1=seq {#2=index based at 1} {#3=true code} {#4=false code}
% True code takes one argument, the retrieved item.
% False code takes no arguments.
\prgNewFunction \brt_seq_item:MmTF {Mmnn}
    {\prgReturn
        {\brt_if:eTF
            {\intCompare {#2} > {\seqVarCount #1}
             || \intCompare {#2} < {1}}
            {\prgReturn {\prgDo {#4}}}
            {\prgReturn {\brtCallAnon {\seqVarItem #1 {#2}} {#3}}}}}

% Rerieve an item from the sequence.
% If the index is out of bounds, then issue an error.
\prgNewFunction \brt_seq_item:Mm {Mm}
    {\prgReturn{\brt_seq_item:MmTF #1 {#2} {\prgReturn {##1}} {\__brt_index_error:nm {#1} {#2}}}}

\DeclareOption {obj} {
    % the quantity of objects with id
    \intNew \g__brt_universe_size

    % \__brt_id_alloc: -> new unique id string
    \strClearNew \l__id
    \prgNewFunction \__brt_id_alloc: {}
        {\strSet \l__id {\evalWhole {brt Id \intUse \g__brt_universe_size}}
         \intIncr \g__brt_universe_size
         \prgReturn {\strUse \l__id}}

    % \brtObjCons {#2=args:keyvals} -> new object
    % If args does not provide @type=, then the object's @type is set to \brtTypeT.
    % The object is automatically given an @id=, which overrides any args.@id.
    % The @id= also serves as a name.
    % If @name= is provided, then it is assigned as a name.
    % The object's formatter is set to the type's default formatter.
    \propClearNew \l__args
    \strClearNew \l__id
    \tlClearNew \l__obj_p
    \prgNewFunction \brtObjCons {m}
        {\propSetFromKeyval \l__args {\evalWhole {#1}}
         \strSet \l__id {\__brt_id_alloc:}
         \propPutIfNew \l__args {@type} {\brtTypeT}
         \propPut \l__args {@id} {\strUse \l__id}
         \tlSet \l__obj_p {\__brt_make:Nm \propConstFromKeyval {\propToKeyval \l__args}}
         \brtObjName {\strUse \l__id} {\tlUse \l__obj_p}
         \propGetT \l__args {@name} \lTmpaTl
             {\brtObjName {\tlUse \lTmpaTl} {\tlUse \l__obj_p}}
         \brtObjFmtLike {\tlUse \l__obj_p} {\brtObjElim {@type} {\tlUse \l__obj_p}}
         \prgReturn {\tlUse \l__obj_p}}

    % \brtObjElim {#1=key:str} #2=obj:obj -> value
    % TODO support attribute paths
    \prgNewFunction \brtObjElim {mM}
        {\prgReturn {\propVarItem #2 {#1}}}

    % \brtObjName {#1=name:str} #2=obj:obj -> void
    % A priori, names can be arbitrary token lists.
    % However, it is recommended that names be valid csnames (without using
    % \csname...\endcsname etc.) so that wrappers can construct convenient macros
    % around object names.
    \prgNewFunction \brtObjName {mM}
        {\tlConst {\expName {c__brt_obj_named_ #1}} #2}

    % \brtObjNamed {#1=name:str} -> object named "name"
    % Maps names to objects, not necessarily injectively.
    % An object's @id= also serves as a name.
    \prgNewFunction \brtObjNamed {m}
        {\prgReturn {\tlUse {\expName {c__brt_obj_named_ #1}}}}

    % \brtObjFmtSet #1=obj:obj {#2=fmtr:fun} -> void
    % Set the formatter for the object.
    \prgNewFunction \__brt_obj_fmt_p: {M}
        {\prgReturn {\expName {\evalWhole {__brt_obj_fmt_ \brtObjElim {@id} #1}}}}
    \prgNewFunction \brtObjFmtSet {Mn}
        {\__brt_fun_del:M {\__brt_obj_fmt_p: #1}
         \prgNewFunction:Mnn {\__brt_obj_fmt_p: #1} {M} {#2}}

    % \brtTypeFmtSet #1=obj:Type -> void
    % Set the formatter for the type, i.e. the default formatter for all inhabitants
    % of this type.
    \prgNewFunction \__brt_type_fmt_p {M}
        {\prgReturn {\expName {\evalWhole {__brt_type_fmt_ \brtObjElim {@id} #1}}}}
    \prgNewFunction \brtTypeFmtSet {Mn}
        {\__brt_fun_del:M {\__brt_type_fmt_p #1}
         \prgNewFunction:Mnn {\__brt_type_fmt_p #1} {M} {#2}}

    % \brtObjFmt #1=obj:obj -> formatted object
    \prgNewFunction \brtObjFmt {M}
        {\prgReturn {\evalWhole {\__brt_obj_fmt_p: #1 #1}}}

    % \brtObjFmtLike #1=obj:obj #2=type:Type -> void
    % Set the formatter for obj to the default formatter of type.
    % This is by ref, i.e. if type's default formatter changes, then so does obj.
    \prgNewFunction \brtObjFmtLike {MM}
        {\brtObjFmtSet #1 {\prgReturn {\evalWhole {\__brt_type_fmt_p #2 ##1}}}}

    % \brtObjShow #1=obj:obj -> string serialisation of object
    \prgNewFunction \brtObjShow {M}
        {\prgReturn {\tlToStr {\propToKeyval #1}}}

    % primitive type type (default formatter)
    % We have to create it by-hand to bootstrap the universe.
    \propConstFromKeyval \brtTypeT {@id = Type, @name = Type}
    \brtObjName {Type} {\brtTypeT}
    \brtObjFmtSet {\brtTypeT} {\prgReturn {\brtObjShow #1}}
    \brtTypeFmtSet {\brtTypeT} {\prgReturn {\brtObjShow #1}}

    % \brtObjPrimElim #1=obj:primitive -> primitive value
    \prgNewFunction \brtObjPrimElim {M}
        {\prgReturn {\brtObjElim {@value} #1}}

    % primitive integer type (eliminates to expl3 integer, formats to arabic)
    \brtTypeFmtSet
        {\brtObjCons {@type = \brtTypeT, @name = Int}}
        {\prgReturn {\int_to_arabic:n {\brtObjPrimElim #1}}}
    \prgNewFunction \brtIntCons {m}
        {\prgReturn
            {\brtObjCons
                {@type = \brtObjNamed {Int},
                 @value = {\__brt_make:Nm \intConst {#1}}}}}

    % primitive string type (eliminates and formats to expl3 string)
    \brtTypeFmtSet
        {\brtObjCons {@type = \brtTypeT, @name = Str}}
        {\prgReturn {\brtObjPrimElim #1}}
    \prgNewFunction \brtStrCons {m}
        {\prgReturn
            {\brtObjCons
                {@type = \brtObjNamed {Str},
                 @value = {\__brt_make:Nm \strConst {#1}}}}}

    % \brtEzObj #1=\csname #2=obj -> void
    % Create two macros, \csname and \csnameO (the O stands for "abstract Object").
    % \csname returns the object formatted, i.e. \brtObjFmt {#2}.
    % \csnameO returns the abstract object, i.e. just #2.
    \prgNewFunction \brtEzObj {MM}
        {\prgNewFunction #1 {} {\prgReturn {\brtObjFmt {#2}}}
         \prgNewFunction:Mnn {\expName {\cs_to_str:N #1 O}} {} {\prgReturn {#2}}}

    % \brtEzType #1=csname #2=type #3=code -> void
    % Create two constructors for `type`, called \csname and \csnameO.
    % The constructor \csname returns a formatted object.
    % The consturctor \csnameO returns an abstract object.
    % The constructor `code` receives a single argument (probably a key-val list)
    % and must return a key-val list that will be passed to \brtObjCons.
    % The `code` does not need to add @type=; that is appended automatically.
    % (TODO: I don't know why but replacing #3 below with something like \prgDo {#3}
    % causes an incromprehensible error.)
    \prgNewFunction \brtEzType {MMn}
        {\prgNewFunction #1 {m}
            {\prgReturn
                {\brtObjFmt
                    {\brtObjCons {#3, @type = #2}}}}
         \prgNewFunction:Mnn {\expName {\cs_to_str:N #1 O}} {m}
            {\prgReturn
                {\brtObjCons {#3, @type = #2}}}}
}

\DeclareOption {breaklessmaths} {
    % never ever break in maths mode
    \binoppenalty=\maxdimen
    \relpenalty=\maxdimen
    \sloppy
}

\DeclareOption {ref} {
    \RequirePackage{hyperref}
    \RequirePackage[nameinlink]{cleverref}
}

\DeclareOption {biblatex} {
    \RequirePackage[backend=bibtex,style=alphabetic,url=false,maxbibnames=4]{biblatex}
    % The user should use \addbibresource after loading this package.
}

\DeclareOption {environments} {
    % TODO
}

\DeclareOption {nestedproofs} {
    \brt_env_set_eq:mm {proofOld} {proof}
    \intZeroNew \g__brt_proof_nesting_level
    \seqClearNew \g__brt_proof_qed_symbols

    % \brtQedSet {#1=comma-delimited list of qed symbols} -> void
    % Set the QED symbols for nested proofs.
    % The left-most symbol is used for the top-level proof whilst the right-most
    % symbol is used for the deepest level proofs.
    \prgNewFunction \brtQedSet {m}
        {\seqSetFromClist \g__brt_proof_qed_symbols {#1}}

    \prgNewFunction \__brt_renew_qed:m {m}
        {\prgReturn {\renewcommand \qedsymbol {#1}}}

    \RenewDocumentEnvironment {proof} {O{Proof}}
        {\intIncr \g__brt_proof_nesting_level % top-most qed will be index 1
         \begin{proofOld}[#1]
         \__brt_renew_qed:m
             {\brt_seq_item:Mm \g__brt_proof_qed_symbols
                 {\intUse \g__brt_proof_nesting_level}}}
        {\end{proofOld}
         \intDecr \g__brt_proof_nesting_level}
}

\DeclareOption {shorthand} {
    % TODO
}

\ProcessOptions\relax
